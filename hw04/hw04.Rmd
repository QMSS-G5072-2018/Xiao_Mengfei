---
title: "QMSS G5072 Homework 4"
author: "Mengfei Xiao"
date: "October 15th, 2018"
output: 
  html_document:
    keep_md: true
---

```{r setup, echo = FALSE, warning = FALSE, message = FALSE}
library(knitr)
opts_chunk$set(fig.path="images/")
```


## Functions in the R Base Package
```{r echo = FALSE, warning = FALSE, message = FALSE}
content <- mget(ls("package:base"), inherits = TRUE)
base_functions <- Filter(is.function, content)
```

#### a) Longest name
My idea to solve this question: I will use names() function to obtain the names of all functions, and then use map() function to compute the length of all function names, where the results are stored in the "length_names" variable with the "list" storage format. In order to compute the maximum, I will use max() function, which needs to be converted to the "vector" format. Finally, calculation results show that the function with the longest name is "getDLLRegisteredRoutines.character", a total of 34 characters.
```{r echo = FALSE, warning = FALSE, message = FALSE}
library(tidyverse)
library(dplyr)
function_names <- names(base_functions) # All the names of the function
length_names <- map(function_names, nchar)
length_names_vector <- c() 
for(i in 1:length(length_names)){
  length_names_vector <- c(length_names_vector,length_names[[i]])
}
```

##### **Function with the longest name**
```{r echo = FALSE, warning = FALSE, message = FALSE}
function_names[which(length_names_vector == max(length_names_vector))]
```

##### **Number of characters**
```{r echo = FALSE, warning = FALSE, message = FALSE}
max(length_names_vector)
```


#### b) Number of arguments
```{r echo = FALSE, warning = FALSE, message = FALSE}
base_fun_args <- map(base_functions, formals)
num_arguments <- sapply(base_fun_args, length)
function_arguments <- data.frame("function" = names(num_arguments), "number_arguments" = num_arguments)
function_top10 <- function_arguments[order(function_arguments$number_arguments, decreasing = TRUE),][1:10,]
rownames(function_top10) <- c(1:nrow(function_top10))
```

```{r echo = FALSE, warning = FALSE, message = FALSE}
# Print out top_10
print(function_top10)
```


#### c) No arguments
Conclusion: By filtering, there are 224 functions with zero argument(no arguments). I think the differences are that most of these functions are basic operators, such as "+"" (addition), "<"(less than), "%%"(modulo), etc, but there are still some primitive functions in it.
```{r echo = FALSE, warning = FALSE, message = FALSE}
non_argumrnts <- function_arguments[function_arguments$number_arguments == 0,]
nrow(non_argumrnts)
```



## Infant Mortality and GPD per Capita
Use the WDI package to obtain country-year data on infant mortality and GDP per capita from the World Bank database: [WDI Package](https://cran.r-project.org/web/packages/WDI/WDI.pdf)


#### a) Highest and lowest infant mortality rates in 2017
```{r echo = FALSE, warning = FALSE, message = FALSE}
library(RJSONIO)
library(WDI)
data_WDI <- WDI(country = "all", indicator = c("NY.GDP.PCAP.PP.KD", "SP.DYN.IMRT.IN"), 
                start = 1960, end = 2017, extra = TRUE, cache = NULL)
```

```{r echo = FALSE, warning = FALSE, message = FALSE}
# Preprocess the dataset
colnames(data_WDI)[colnames(data_WDI) == "NY.GDP.PCAP.PP.KD"] <- "gdpcap"
colnames(data_WDI)[colnames(data_WDI) == "SP.DYN.IMRT.IN"] <- "infmort"
data_WDI_clean <- data_WDI %>% filter(data_WDI$region != "Aggregates")
```

```{r echo = FALSE, warning = FALSE, message = FALSE}
# Highest and lowest infant mortality rates in 2017 
data_2017 <- select(data_WDI_clean, year, country, region, infmort, gdpcap) %>% filter(year == 2017)
infmort_top5 <- select(data_2017, country, infmort, gdpcap) %>% 
  arrange(desc(infmort)) %>%
  head(5)
infmort_last5 <- select(data_2017, country, infmort, gdpcap) %>% 
  arrange(infmort) %>%
  head(5)
```

##### **Table of countries with the 5 highest infant mortality rates in 2017**
```{r echo = FALSE, warning = FALSE, message = FALSE}
print(infmort_top5)
```

##### **Table of countries with the 5 lowest infant mortality rates in 2017**
```{r echo = FALSE}
print(infmort_last5)
```


#### b) Overall regression
Conclusion: According to the question, I regard ¡°gdpcap¡± as independent variable, ¡°infmort¡± as dependent variable. The fit line indicates that infmort is inversely proportional to gdpcap. Almost all of scatters concentrate on the bottom left corner of plot, with a lower gdpcap value but higher infmort value, which means that the lower GDP per capita, the higher infant mortality rate overall. Besides, in the range of 0 to 5e+04, the infant morality rate is falling very fast, but after that, the rate is gradually getting slowly, which means the impact of GDP per capita on infant mortality rate is not so significant.
```{r echo = FALSE, warning = FALSE, message = FALSE}
lm1 <- lm(infmort~gdpcap, data_WDI_clean, subset = ((!is.na(gdpcap)) & (!is.na(infmort))))
summary(lm1)
```

```{r echo = FALSE, warning = FALSE, message = FALSE}
library(ggplot2)
ggplot(data_WDI_clean, aes(x = gdpcap, y = infmort)) + 
  geom_point() + geom_smooth(method = lm) + 
  labs(title = "The relationship between gdpcap & infmort")
```

#### c) Regression by region
My idea to solve this question: I divide the data into ¡°region¡± variables and store in the list. Then, I fit the linear regression function for the two variables GDP per capita and infant mortality in each region, and the fitting coefficient results are sorted as shown below.
```{r echo = FALSE, warning = FALSE}
# Split the data set
data_WDI_clean <- data_WDI_clean[(!is.na(data_WDI_clean$gdpcap)) & (!is.na(data_WDI_clean$infmort)),]
split_region <- split(data_WDI_clean, data_WDI_clean$region, drop = TRUE)
str(split_region, max.level = 1)
```

```{r echo = FALSE, warning = FALSE, message = FALSE}
coefs_region <- map(split_region, ~lm(infmort ~ gdpcap, data = .)) %>%
  map(~ coef(.)) %>%
  map_dbl("gdpcap") %>%
  sort()
coefs_region <- data.frame("region" = names(coefs_region), "coefs_region" = coefs_region)
rownames(coefs_region) <- c(1:nrow(coefs_region))
```

```{r echo = FALSE, warning = FALSE, message = FALSE}
# Print out the table
print(coefs_region)
```


#### d) Regression by country
```{r echo = FALSE}
R_Square <- data_WDI_clean %>%
  split(data_WDI_clean$country) %>%
  map(~ lm(infmort ~ gdpcap, data = .)) %>%
  map(summary) %>%
  map_dbl("r.squared") # R-square
lm_country <- data_WDI_clean %>%
  split(data_WDI_clean$country) %>%
  map(~ lm(infmort~gdpcap, data = .)) %>%
  map(summary)
coef_country <- sapply(lm_country, function(x) x$coefficients[2])
pvalue_country <- sapply(lm_country, function(x) x$coefficients[8])
lm_table_country <- data.frame("Country" = names(R_Square),
                               "R_squared" = R_Square,
                               "Coefficient" = coef_country,
                               "P_value" = pvalue_country)
lm_table_country <- lm_table_country[!is.na(lm_table_country$Coefficient),]
```

##### **The percentage of the positive relationship between GDP per capita and infant mortality**
```{r echo = FALSE, warning = FALSE, message = FALSE}
nrow(lm_table_country[lm_table_country$Coefficient > 0 
                      & lm_table_country$P_value < 0.05,])/nrow(lm_table_country)
```

##### **Make a histogram of the slope coefficients**
```{r echo = FALSE, warning = FALSE, message = FALSE}
hist(coef_country)
```

##### **The country cases with the most at odds in the overall regression**
```{r echo = FALSE, warning = FALSE, message = FALSE}
differs <- abs(lm_table_country$Coefficient - lm1$coefficients[2])
lm_table_country[which(differs == max(differs, na.rm = TRUE)),]
```



#### e) Added squared term
Conclusion: I add the adjusted R-squared value of GDP to the model, the independent variable is ¡°gdpcap ^ 2 + gdpcap¡±. Compared with the results of Question d) as the plot shows below, the x-axis of plot is ¡°no_squared¡±(not adding adjusted R-squared value), the y-axis is ¡°squared¡±(adding adjusted R-squared value). It can be seen that, most of the scatters concentrate on the upper right corner, that is, as for the same sample, adding the adjusted R-squared value is bigger, so the fitting effect of the model is better. Generally, it is better to look at adding adjusted R-squared rather than not adding since the model becomes more accurately, I recommend to keep the squared term.
```{r echo = FALSE}
R_Square_square <- data_WDI_clean %>%
  split(data_WDI_clean$country) %>%
  map(~ lm(infmort~gdpcap + I(gdpcap^2), data = .)) %>%
  map(summary) %>%
  map_dbl("r.squared") # R-square
lm_table_country_2 <- data.frame("Country" = names(R_Square_square),
                               "R.squared" = R_Square_square)
lm_table_country_2 <- lm_table_country_2[!is.na(lm_table_country_2$R.squared),]
# Merge 2 tables
differ_R <- merge(x = lm_table_country, y = lm_table_country_2,
                   by.x = "Country", by.y = "Country")
names(differ_R)[c(2,5)] <- c("no_squared","squared")
differ_R$differ <- differ_R$squared - differ_R$no_squared
plot(differ_R$no_squared, differ_R$squared)
```

##### **The difference of the average model adjusted R-squared**
```{r echo = FALSE}
avg_adjusted_added <- mean(differ_R$squared)
avg_adjusted_no_added <- mean(differ_R$no_squared)
difference <- avg_adjusted_added - avg_adjusted_no_added
difference
```

